{% extends "base.html" %}

{% block title %}Upload File - AFHArchive{% endblock %}

{% block content %}
<div class="row">
    <div class="col-lg-8">
        <div class="card">
            <div class="card-header">
                <h3><i class="fas fa-upload"></i> Upload File to AFHArchive</h3>
            </div>
            <div class="card-body">
                <div class="alert alert-warning">
                    <h5><i class="fas fa-exclamation-triangle"></i> Important Guidelines</h5>
                    <ul class="mb-0">
                        <li><strong>Only upload files that were previously hosted on AndroidFileHost</strong></li>
                        <li>Provide as much metadata as possible to help with approval</li>
                        <li>Include the original AFH link if you have it</li>
                        <li>All uploads are pending review - new builds will not be approved</li>
                        <li>Do not upload password protected archives, they will not be approved</li>
                        <li>Maximum file size: 5GB</li>
                    </ul>
                </div>

                <form method="POST" enctype="multipart/form-data" id="upload-form">
                    <div class="mb-3">
                        <label for="file" class="form-label">Select File *</label>
                        <input type="file" class="form-control" id="file" name="file" required 
                               accept=".zip,.apk,.img,.tar,.gz,.xz,.7z,.rar,.md5">
                        <div class="form-text">Allowed formats: ZIP, APK, IMG, TAR, GZ, XZ, 7Z, RAR, MD5</div>
                    </div>

                    <!-- Progress bar (hidden initially) -->
                    <div class="mb-3" id="progress-container" style="display: none;">
                        <label class="form-label">Upload Progress</label>
                        <div class="progress" style="height: 25px;">
                            <div class="progress-bar progress-bar-striped progress-bar-animated" 
                                 role="progressbar" id="progress-bar" style="width: 0%">
                                <span id="progress-text">0%</span>
                            </div>
                        </div>
                        <div class="mt-2">
                            <small class="text-muted">
                                <span id="upload-status">Preparing upload...</span>
                                <span id="upload-speed" class="float-end"></span>
                            </small>
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="device_manufacturer" class="form-label">Device Manufacturer *</label>
                                <input type="text" class="form-control" id="device_manufacturer" name="device_manufacturer" 
                                       placeholder="e.g., Samsung, Google, OnePlus" required>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="device_model" class="form-label">Device Model *</label>
                                <input type="text" class="form-control" id="device_model" name="device_model" 
                                       placeholder="e.g., Galaxy S21, Pixel 6, Generic" required>
                            </div>
                        </div>
                    </div>

                    <div class="mb-3">
                        <label for="afh_link" class="form-label">Original AndroidFileHost Link</label>
                        <input type="url" class="form-control" id="afh_link" name="afh_link" 
               placeholder="https://androidfilehost.com/?fid=...">
        <div class="invalid-feedback" id="afh-link-feedback" style="display:none;">
            Folder links are not allowed. Please provide a file link instead.
        </div>
                        <div class="form-text">If you have the original AFH link, please provide it</div>
                    </div>

                    <div class="mb-3">
                        <label for="xda_thread" class="form-label">XDA Thread Link</label>
                        <input type="url" class="form-control" id="xda_thread" name="xda_thread" 
                               placeholder="https://forum.xda-developers.com/...">
                        <div class="form-text">Link to the XDA thread where this file was discussed</div>
                    </div>

                    <div class="mb-3">
                        <label for="notes" class="form-label">Additional Notes</label>
                        <textarea class="form-control" id="notes" name="notes" rows="4" 
                                  placeholder="Any additional information about this file, ROM version, build date, etc."></textarea>
                    </div>

                    <button type="submit" class="btn btn-primary btn-lg" id="upload-btn">
                        <i class="fas fa-upload"></i> Upload File
                    </button>
                    <button type="button" class="btn btn-secondary btn-lg" id="cancel-btn" style="display: none;">
                        <i class="fas fa-times"></i> Cancel Upload
                    </button>
                </form>
            </div>
        </div>
    </div>

    <div class="col-lg-4">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-info-circle"></i> Upload Process</h5>
            </div>
            <div class="card-body">
                <ol>
                    <li>Select your file (max 5GB)</li>
                    <li>Fill in required metadata</li>
                    <li>Admin reviews for AFH authenticity</li>
                    <li>Approved files become available</li>
                </ol>
                <div class="alert alert-info mt-3">
                    <small><strong>Note:</strong> Only files that were previously on AndroidFileHost will be approved for preservation.</small>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
let uploadState = {
    uploadId: null,
    file: null,
    chunks: [],
    currentChunk: 0,
    totalChunks: 0,
    chunkSize: 5 * 1024 * 1024, // 5MB
    startTime: null,
    uploadedBytes: 0,
    cancelled: false,
    activeXHR: null
};

document.getElementById('file').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) {
        const maxSize = 5 * 1024 * 1024 * 1024; // 5GB
        if (file.size > maxSize) {
            alert('File is too large. Maximum size is 5GB.');
            e.target.value = '';
        }
    }
});

document.getElementById('upload-form').addEventListener('submit', async function(e) {
    e.preventDefault();
    const file = document.getElementById('file').files[0];
    if (!file) {
        alert('Please select a file to upload.');
        return;
    }
    // Validate required fields
    const manufacturer = document.getElementById('device_manufacturer').value.trim();
    const model = document.getElementById('device_model').value.trim();
    if (!manufacturer) {
        alert('Device manufacturer is required.');
        return;
    }
    if (!model) {
        alert('Device model is required.');
        return;
    }
    // Validate AFH link (must not be a folder link)
    const afhLinkInput = document.getElementById('afh_link');
    const afhLink = afhLinkInput.value.trim();
    const feedback = document.getElementById('afh-link-feedback');
    if (afhLink && (afhLink.includes('flid=') || afhLink.includes('a=show&w=files'))) {
        afhLinkInput.classList.add('is-invalid');
        feedback.style.display = 'block';
        afhLinkInput.focus();
        return;
    } else {
        afhLinkInput.classList.remove('is-invalid');
        feedback.style.display = 'none';
    }
    // Start chunked upload asynchronously
    await startChunkedUpload(file, {
        deviceManufacturer: manufacturer,
        deviceModel: model,
        afhLink: afhLink,
        xdaThread: document.getElementById('xda_thread').value.trim(),
        notes: document.getElementById('notes').value.trim()
    });
});

async function startChunkedUpload(file, metadata) {
    try {
        // Reset state
        uploadState.file = file;
        uploadState.currentChunk = 0;
        uploadState.uploadedBytes = 0;
        uploadState.cancelled = false;
        uploadState.startTime = Date.now();
        
        // Show progress UI
        showUploadProgress();
        updateStatus('Initializing upload...');
        
        // Initialize upload session
        const initResponse = await fetch('/api/upload-init', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                filename: file.name,
                fileSize: file.size
            })
        });
        
        const initData = await initResponse.json();
        
        if (!initData.success) {
            throw new Error(initData.error || 'Failed to initialize upload');
        }
        
        uploadState.uploadId = initData.uploadId;
        uploadState.chunkSize = initData.chunkSize;
        uploadState.totalChunks = initData.totalChunks;
        
        // Start uploading chunks
        updateStatus('Starting chunk upload...');
        await uploadChunks(metadata);
        
    } catch (error) {
        console.error('Upload error:', error);
        handleUploadError(error.message || 'Upload failed');
    }
}

async function uploadChunks(metadata) {
    const file = uploadState.file;
    for (let i = 0; i < uploadState.totalChunks; i++) {
        if (uploadState.cancelled) {
            throw new Error('Upload cancelled');
        }
        uploadState.currentChunk = i;
        const start = i * uploadState.chunkSize;
        const end = Math.min(start + uploadState.chunkSize, file.size);
        const chunk = file.slice(start, end);
        await uploadSingleChunk(chunk, i, uploadState.totalChunks);
        uploadState.uploadedBytes += chunk.size;
        updateProgress();
    }
    await completeUpload(metadata);
}

async function uploadSingleChunk(chunk, chunkIndex, totalChunks) {
    return new Promise((resolve, reject) => {
        const formData = new FormData();
        formData.append('chunk', chunk);
        formData.append('chunkIndex', chunkIndex);
        formData.append('totalChunks', totalChunks);
        formData.append('uploadId', uploadState.uploadId);
        
        const xhr = new XMLHttpRequest();
        uploadState.activeXHR = xhr;
        
        xhr.onload = function() {
            if (this.status === 200) {
                try {
                    const response = JSON.parse(this.responseText);
                    if (response.success) {
                        resolve(response);
                    } else {
                        reject(new Error(response.error || 'Chunk upload failed'));
                    }
                } catch (e) {
                    reject(new Error('Invalid response from server'));
                }
            } else {
                reject(new Error(`Chunk upload failed with status: ${this.status}`));
            }
        };
        
        xhr.onerror = function() {
            reject(new Error('Network error during chunk upload'));
        };
        
        xhr.onabort = function() {
            reject(new Error('Chunk upload cancelled'));
        };
        
        xhr.open('POST', '/api/upload-chunk');
        xhr.send(formData);
    });
}

async function completeUpload(metadata) {
    updateStatus('Assembling file...');
    const completeData = {
        uploadId: uploadState.uploadId,
        totalChunks: uploadState.totalChunks,
        originalFilename: uploadState.file.name,
        deviceManufacturer: metadata.deviceManufacturer,
        deviceModel: metadata.deviceModel,
        afhLink: metadata.afhLink,
        xdaThread: metadata.xdaThread,
        notes: metadata.notes
    };
    const response = await fetch('/api/upload-complete', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(completeData)
    });
    const result = await response.json();
    if (!result.success) {
        throw new Error(result.error || 'Failed to complete upload');
    }
    updateStatus('Upload completed successfully!');
    document.getElementById('progress-bar').className = 'progress-bar bg-success';
    setTimeout(function() {
        window.location.href = '/my-uploads';
    }, 2000);
}

function updateProgress() {
    const percentComplete = (uploadState.uploadedBytes / uploadState.file.size) * 100;
    const progressBar = document.getElementById('progress-bar');
    const progressText = document.getElementById('progress-text');
    const uploadSpeed = document.getElementById('upload-speed');
    
    progressBar.style.width = percentComplete + '%';
    progressText.textContent = Math.round(percentComplete) + '%';
    
    // Calculate upload speed
    const elapsed = (Date.now() - uploadState.startTime) / 1000; // seconds
    const bytesPerSecond = uploadState.uploadedBytes / elapsed;
    const mbPerSecond = bytesPerSecond / (1024 * 1024);
    
    if (percentComplete < 100) {
        uploadSpeed.textContent = `${mbPerSecond.toFixed(1)} MB/s`;
        updateStatus(`Uploading chunk ${uploadState.currentChunk + 1} of ${uploadState.totalChunks}... ${formatBytes(uploadState.uploadedBytes)} of ${formatBytes(uploadState.file.size)}`);
    } else {
        uploadSpeed.textContent = '';
    }
}

function updateStatus(message) {
    document.getElementById('upload-status').textContent = message;
}

function showUploadProgress() {
    document.getElementById('progress-container').style.display = 'block';
    document.getElementById('upload-btn').style.display = 'none';
    document.getElementById('cancel-btn').style.display = 'inline-block';
    
    // Disable form inputs
    const inputs = document.querySelectorAll('#upload-form input, #upload-form textarea, #upload-form button');
    inputs.forEach(input => {
        if (input.id !== 'cancel-btn') {
            input.disabled = true;
        }
    });
}

// Cancel upload functionality
document.getElementById('cancel-btn').addEventListener('click', function() {
    uploadState.cancelled = true;
    
    if (uploadState.activeXHR) {
        uploadState.activeXHR.abort();
    }
    
    resetUploadForm();
});

function handleUploadError(message) {
    updateStatus(message);
    document.getElementById('progress-bar').className = 'progress-bar bg-danger';
    document.getElementById('upload-speed').textContent = '';
    
    setTimeout(function() {
        resetUploadForm();
    }, 3000);
}

function resetUploadForm() {
    // Hide progress bar
    document.getElementById('progress-container').style.display = 'none';
    
    // Reset progress bar
    const progressBar = document.getElementById('progress-bar');
    progressBar.style.width = '0%';
    progressBar.className = 'progress-bar progress-bar-striped progress-bar-animated';
    document.getElementById('progress-text').textContent = '0%';
    
    // Show upload button, hide cancel button
    document.getElementById('upload-btn').style.display = 'inline-block';
    document.getElementById('cancel-btn').style.display = 'none';
    
    // Re-enable form inputs
    const inputs = document.querySelectorAll('#upload-form input, #upload-form textarea, #upload-form button');
    inputs.forEach(input => input.disabled = false);
    
    // Reset state
    uploadState = {
        uploadId: null,
        file: null,
        chunks: [],
        currentChunk: 0,
        totalChunks: 0,
        chunkSize: 1 * 1024 * 1024,
        startTime: null,
        uploadedBytes: 0,
        cancelled: false,
        activeXHR: null
    };
}

function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}


</script>

<!-- Include SparkMD5 for client-side MD5 calculation -->
<script src="https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js"></script>
{% endblock %}
